---
engine: knitr
---

# Static communication {#sec-static-communication}

**Required material**

- Read *R for Data Science*, Chapter 2 "Data visualization", [@r4ds]
  - This chapter provides an overview of `ggplot2`.
- Read *Data Visualization: A Practical Introduction*, Chapter 3 "Make a plot", [@healyviz]
  - This chapter provides another overview of `ggplot2`, but this one provides more details about certain aspects.
- Watch *The Glamour of Graphics*, [@chase2020]
  - This video details ideas for how to improve a plot made with `ggplot2`.
- Read *Testing Statistical Charts: What Makes a Good Graph?*, [@vanderplas2020testing]
  - This article details best practice for making graphs.
- Read *Data Feminism*, Chapter 3 "On Rational, Scientific, Objective Viewpoints from Mythical, Imaginary, Impossible Standpoints", [@datafeminism2020]
  - This chapter provides clear examples of how data needs to be considered within context.
- Read *Historical development of the graphical representation of statistical data*, Chapter 2, "The Origin of the Graphic Method", [@funkhouser1937historical]
  - This chapter discusses how various types of graphs developed.

**Key concepts and skills**

- We must show the reader the actual observations in the dataset, or as close as is possible, through graphs and tables. This is because it is only through visualization that we can get a true sense of our data. This means that we need to develop a comfort with a variety of graph options, including: bar charts, scatterplots, line plots, and histograms. We can even consider a map to be a type of graph, especially after geocoding our data.
- That said, we also must know when to summarize data, for instance using tables. Typical use cases for this include showing part of a dataset, summary statistics, and regression results. 

**Key packages and functions**

- Base R [@citeR]
  - `lm()`
- `datasauRus` [@citedatasauRus]
- `ggmap` [@KahleWickham2013]
	- `get_googlemap()`
	- `get_stamenmap()`
	- `ggmap()`
- Core `tidyverse` [@tidyverse]
	- `ggplot2` [@citeggplot]
		- `coord_map()`
		- `facet_wrap()`
		- `geom_abline()`
		- `geom_bar()`
		- `geom_boxplot()`
		- `geom_dotplot()`
		- `geom_freqpoly()`
		- `geom_histogram()`
		- `geom_jitter()`
		- `geom_line()`
		- `geom_path()`
		- `geom_point()`
		- `geom_polygon()`
		- `geom_smooth()`
		- `geom_step()`
		- `ggplot()`
		- `ggsave()`
		- `labeller()`
		- `labs()`
		- `map_data()`
		- `scale_color_brewer()`
		- `scale_colour_viridis_d()`
		- `scale_fill_brewer()`
		- `scale_fill_viridis()`
		- `stat_qq()`
		- `stat_qq_line()`
		- `theme()`
		- `theme_bw()`
		- `theme_classic()`
		- `theme_linedraw()`
		- `theme_minimal()`
- `kableExtra` [@citekableextra]
	- `add_header_above()`
- `knitr` [@citeknitr]
	- `kable()`
- `maps` [@citemaps]
	- `map()`
- `modelsummary` [@citemodelsummary]
	- `datasummary()`
	- `datasummary_balance()`
	- `datasummary_correlation()`
	- `datasummary_skim()`
	- `modelsummary()`
- `opendatatoronto` [@citeSharla]
- `patchwork` [@citepatchwork]
- `viridis` [@viridis]
- `WDI` [@WDI]
	- `WDI()`
	- `WDIsearch()`

## Introduction

When telling stories with data, we would like the data to do much of the work of convincing our reader. The paper is the medium, and the data are the message. To that end, we want to try to show our reader the data that allowed us to come to our understanding of the story. We use graphs, tables, and maps to help achieve this. 

The critical task is to show the actual observations that underpin our analysis, or as close to them as we can. For instance, if our dataset consists of 2,500 responses to a survey, then at some point in the paper we would expect a graph that contains, or represents, all 2,500 observations, for every variable of interest. To do this we build graphs using `ggplot2` [@citeggplot] which is part of the `tidyverse` [@tidyverse]. We will go through a variety of different options here including bar charts, scatterplots, line plots, and histograms.

In contrast to the role of graphs, which is to show the actual observations, or as close to them as possible, the role of tables is typically to show an extract of the dataset, convey various summary statistics, or regression results. We will build tables primarily using `knitr` [@citeknitr], which we will extend with `kableExtra` [@citekableextra]; later we will use `modelsummary` [@citemodelsummary] to build tables related to regression output.

Finally, we cover maps as a variant of graphs that are used to show a particular type of data. We will build static maps using `ggmap` [@KahleWickham2013], having obtained the geocoded data that we need using `tidygeocoder` [@citetidygeocoder].

## Graphs

> A world turning to a saner and richer civilization will be a world turning to charts.
> 
> @karsetn [p. 684]

Graphs are a critical aspect of compelling stories told with data. They allow us to see both broad patterns and detail [@elementsofgraphingdata, p. 5]. Graphs provide us with a familiarity with our data that no other method allows. Every variable of interest should be graphed. A graph 'is a representation of abstract relations' [@karsetn, p. 684].

In a way, the graphing of data is an information coding process where we use purposeful marks to convey information to our audience. The audience must decode these marks. The success of our graph turns on how much information is lost in this process. It is the decoding that is the critical aspect [@elementsofgraphingdata, p. 221]. Which means that we must focus on creating effective graphs for the audience. The most important objective of a graph is to convey as much of the actual data, and its context, as possible. 

To see why conveying the actual data is important, consider a dataset from `datasauRus` [@citedatasauRus]. After installing and loading the necessary packages, we can take a quick look at the dataset.

```{r}
#| eval: false
#| echo: true

install.packages("datasauRus")
```

```{r}
#| message: false

library(tidyverse)
library(datasauRus)

head(datasaurus_dozen)
datasaurus_dozen |>
  count(dataset)
```

The dataset consists of values for "x" and "y", which should be plotted on the x-axis and y-axis, respectively. We can further see that there are thirteen different values in the variable "dataset" including: "dino", "star", "away", and "bullseye". We will focus on those four and generate summary statistics for each (@tbl-datasaurussummarystats).

```{r}
#| label: tbl-datasaurussummarystats
#| tbl-cap: "Mean and standard deviation for four 'datasaurus' datasets"
#| message: false

# From Julia Silge:
# https://juliasilge.com/blog/datasaurus-multiclass/
datasaurus_dozen |>
  filter(dataset %in% c("dino", "star", "away", "bullseye")) |>
  group_by(dataset) |>
  summarise(
    across(c(x, y), list(mean = mean, sd = sd)),
    x_y_cor = cor(x, y)) |>
  knitr::kable(
    col.names = c(
    "Dataset", "x mean", "x sd", "y mean", "y sd", "correlation"
    ),
    digits = 1,
    booktabs = TRUE,
    linesep = ""
  )
```

Despite the similarities of the summary statistics, it turns out the different "datasets" are actually very different beasts. This becomes clear when we graph the actual data (@fig-datasaurusgraph).

```{r}
#| eval: true
#| fig-cap: "Graph of four 'datasaurus' datasets"
#| label: fig-datasaurusgraph
#| warning: false
#| echo: true

datasaurus_dozen |>
  filter(dataset %in% c("dino", "star", "away", "bullseye")) |>
  ggplot(aes(x = x, y = y, colour = dataset)) +
  geom_point() +
  theme_minimal() +
  facet_wrap(vars(dataset), nrow = 2, ncol = 2) +
  labs(color = "Dataset")
```

This is a variant of the famous "Anscombe's Quartet" which comes with R. The key takeaway is that it is important to plot the actual data and not rely on summary statistics.

```{r}
head(anscombe)
```

::: {.content-visible when-format="pdf"}
Anscombe's Quartet consists of six observations for four different datasets, with x and y values for each observation. We need to manipulate this dataset with `pivot_longer()` to get it into the "tidy" format discussed in the ["R Essentials" Online Appendix](https://tellingstorieswithdata.com/20-r_essentials.html).
:::

::: {.content-visible unless-format="pdf"}
Anscombe's Quartet consists of six observations for four different datasets, with x and y values for each observation. We need to manipulate this dataset with `pivot_longer()` to get it into the "tidy" format discussed in @sec-r-essentials. 
:::


```{r}
# From Nick Tierney:
# https://www.njtierney.com/post/2020/06/01/tidy-anscombe/
# Code from pivot_longer() vignette.

tidy_anscombe <-
  anscombe |>
  pivot_longer(
    everything(),
    names_to = c(".value", "set"),
    names_pattern = "(.)(.)"
  )
```

We can first create summary statistics (@tbl-anscombesummarystats) and then graph the data (@fig-anscombegraph). This shows the importance of graphing the actual data, rather than relying on summary statistics.

```{r}
#| label: tbl-anscombesummarystats
#| message: false
#| tbl-cap: "Mean and standard deviation for Anscombe's quartet"

tidy_anscombe |>
  group_by(set) |>
  summarise(
    across(c(x, y), list(mean = mean, sd = sd)),
    x_y_cor = cor(x, y)
    ) |>
  knitr::kable(
    col.names = c(
    "Dataset", "x mean", "x sd", "y mean", "y sd", "correlation"
    ),
    digits = 1,
    booktabs = TRUE,
    linesep = ""
  )
```


```{r}
#| eval: true
#| fig-cap: "Recreation of Anscombe's Quartet"
#| label: fig-anscombegraph
#| warning: false
#| echo: true

tidy_anscombe |>
  ggplot(aes(x = x, y = y, colour = set)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE) +
  theme_minimal() +
  facet_wrap(vars(set), nrow = 2, ncol = 2) +
  labs(colour = "Dataset")
```


::: {.content-visible when-format="pdf"}
Graphs can be ugly, bad, and wrong [@wilke2019fundamentals]. Initially, it is enough to try to avoid such shortcomings, but in practice one quickly wants to move beyond that. There are many different `ggplot2` options and a helpful reference sheet is provided by [Isabella Benabaue](https://isabella-b.com/blog/ggplot2-theme-elements-reference/). And [Yan Holtz](https://www.dataviz-inspiration.com) provides examples of beautiful and impactful data visualization. As mentioned in the ["R Essentials" Online Appendix](https://tellingstorieswithdata.com/20-r_essentials.html) `ggplot2` implements a grammar of graphics, which describes a plot as comprising data with aesthetic attributes such as layer, scales, coordinates, facets, and themes [@citeggplot].
:::

::: {.content-visible unless-format="pdf"}
Graphs can be ugly, bad, and wrong [@wilke2019fundamentals]. Initially, it is enough to try to avoid such shortcomings, but in practice one quickly wants to move beyond that. There are many different `ggplot2` options and a helpful reference sheet is provided by [Isabella Benabaue](https://isabella-b.com/blog/ggplot2-theme-elements-reference/). And [Yan Holtz](https://www.dataviz-inspiration.com) provides examples of beautiful and impactful data visualization. As mentioned in @sec-r-essentials `ggplot2` implements a grammar of graphics, which describes a plot as comprising data with aesthetic attributes such as layer, scales, coordinates, facets, and themes [@citeggplot].
:::


### Bar charts

We typically use a bar chart when we have a categorical variable that we want to focus on. We saw an example of this in @sec-fire-hose where we constructed a graph of the number of occupied beds. The geom that we primarily use is `geom_bar()`, but there are many variants to cater for specific situations. To illustrate the use of bar charts, we use a dataset from the 1997-2001 British Election Panel Study that was put together by @fox2006effect.

::: {.content-visible when-format="pdf"}
```{r}
#| include: true
#| eval: false

# Vincent Arel Bundock provides access to this dataset.
beps <-
  read_csv(
    file =
      paste0(
      "https://vincentarelbundock.github.io/Rdatasets/",
      "csv/carData/BEPS.csv")
  )
```
:::

::: {.content-visible unless-format="pdf"}
```{r}
#| include: true
#| eval: false

# Vincent Arel Bundock provides access to this dataset.
beps <-
  read_csv(
    file =
      "https://vincentarelbundock.github.io/Rdatasets/csv/carData/BEPS.csv"
  )
```
:::

```{r}
#| include: false
#| eval: false

# INTERNAL
write_csv(
  beps,
  "inputs/data/beps.csv"
)
```

```{r}
#| include: false
#| eval: true

# INTERNAL
beps <-
  read_csv(
    file = "inputs/data/beps.csv"
  )
```

```{r}
#| include: true
#| eval: true

head(beps)
```

The dataset consists of which party the respondent supports, along with various demographic, economic, and political variables. In particular, we have the age of the respondents. We begin by creating age-groups from the ages, and making a bar chart showing the frequency of each age-group using `geom_bar()` (@fig-bepfitst).

```{r}
#| label: fig-bepfitst
#| eval: true
#| fig-cap: "Distribution of ages in the 1997-2001 British Election Panel Study"
#| warning: false
#| echo: true

beps <-
  beps |>
  mutate(
    age_group =
      case_when(
        age < 35 ~ "<35",
        age < 50 ~ "35-49",
        age < 65 ~ "50-64",
        age < 80 ~ "65-79",
        age < 100 ~ "80-99"
      ),
    age_group = factor(
      age_group,
      levels = c(
        "<35",
        "35-49",
        "50-64",
        "65-79",
        "80-99"
      )
    )
  )

beps |>
  ggplot(mapping = aes(x = age_group)) +
  geom_bar()
```

By default, `geom_bar()` creates a count of the number of times each age-group appears in the dataset. It does this because the default "stat" for `geom_bar()` is "count", which saves us from having to create that statistic ourselves. But if we had already constructed a count (for instance, `beps |> count(age)`), then we could also specify a column of values for the y-axis and use `stat = "identity"`.

We may also like to consider different groupings of the data to get a different insight. For instance, we can look at which party the respondent supports, by age-group (@fig-bepsecond).

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-group, and vote preference, in the 1997-2001 British Election Panel Study"
#| label: fig-bepsecond
#| warning: false

beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar()
```

By default, these different groups are stacked, but they can be placed side-by-side with `position = "dodge2"` (@fig-bepthird).

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-groups, and vote preference, in the 1997-2001 British Election Panel Study"
#| label: fig-bepthird
#| warning: false

beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar(position = "dodge2")
```

At this point, we may like to address the general look of the graph. There are various themes that are built into `ggplot2`. Some of these include `theme_bw()`, `theme_classic()`, `theme_dark()`, and `theme_minimal()`. A full list is available in the `ggplot2` [cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/data-visualization.pdf). We can use these themes by adding them as a layer (@fig-bepthemes). We can install themes from other packages, including `ggthemes` [@ggthemes], and `hrbrthemes` [@hrbrthemes]. And we can also build our own.

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-groups, and vote preference, in the 1997-2001 British Election Panel Study, illustrating different themes and the use of `patchwork`"
#| label: fig-bepthemes
#| warning: false

library(patchwork)

theme_bw <-
  beps |>
  ggplot(mapping = aes(x = age_group)) +
  geom_bar(position = "dodge") +
  theme_bw()

theme_classic <-
  beps |>
  ggplot(mapping = aes(x = age_group)) +
  geom_bar(position = "dodge") +
  theme_classic()

theme_dark <-
  beps |>
  ggplot(mapping = aes(x = age_group)) +
  geom_bar(position = "dodge") +
  theme_dark()

theme_minimal <-
  beps |>
  ggplot(mapping = aes(x = age_group)) +
  geom_bar(position = "dodge") +
  theme_minimal()

(theme_bw + theme_classic) / (theme_dark + theme_minimal)
```

There are a variety of ways to have multiple plots. These include the use of sub-figures, which was covered in @sec-quartocrossreferences, and `patchwork` [@citepatchwork], which we illustrate in @fig-bepthemes (and we will cover a third soon). Here we are using `patchwork` to bring together multiple graphs. To do this, we assign the graph to a name, then use "+" to signal which should be next to each other, "/" to signal which would be on top, and use brackets to indicate precedence

The default labels used by `ggplot2` are the name of the relevant variable, and it is often useful to add more detail. We could also add a title and caption. A caption can be useful to add information about the source of the dataset. A title can be useful when the graph is going to be considered outside of the context of our paper. But in the case of a graph that will be included in a paper, the need to cross-reference all graphs that are in a paper means that including a title within `labs()` is unnecessary (@fig-withnicelabels).

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-groups, and vote preference, in the 1997-2001 British Election Panel Study"
#| label: fig-withnicelabels
#| warning: false

beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(
    x = "Age-group of respondent",
    y = "Number of respondents",
    fill = "Voted for",
    title = "Distribution of age-groups, and vote preference, in
       the 1997-2001 British Election Panel Study",
    caption = "Source: 1997-2001 British Election Panel Study."
  )
```

We use facets to show variation, based on one or more variables [@grammarofgraphics, p. 219]. Facets are especially useful when we have already used color to highlight variation in some other variable and add an additional dimension. For instance, we may be interested to explain vote, by age and gender (@fig-facets) (there will be a problem with overlapping x axis labels here, which we will address later).

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-group by gender, and vote preference, in the 1997-2001 British Election Panel Study"
#| label: fig-facets
#| warning: false

beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(
    x = "Age-group of respondent",
    y = "Number of respondents",
    fill = "Voted for"
  ) +
  facet_wrap(vars(gender))
```

We could change `facet_wrap()` to wrap vertically instead of horizontally with `dir = "v"`. Alternatively, we could specify a few rows, say `nrow = 2`, or a number of columns, say `ncol = 2`. By default, both facets will have the same scale. We could enable both facets to have different scales, `scales = "free"`, or just the x-axis `scales = "free_x"`, or just the y-axis `scales = "free_y"` (@fig-facetsfancy). Here we will also change the position of the legend with `theme(legend.position="bottom")`.

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-group by gender, and vote preference, in the 1997-2001 British Election Panel Study"
#| label: fig-facetsfancy
#| warning: false

beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(
    x = "Age-group of respondent",
    y = "Number of respondents",
    fill = "Voted for"
  ) +
  facet_wrap(
    vars(gender),
    dir = "v",
    scales = "free"
  ) +
  theme(legend.position = "bottom")
```

Finally, we can change the labels of the facets using `labeller()` (@fig-facetsfancylabels). 

```{r}
#| echo: true
#| eval: true
#| fig-cap: "Distribution of age-group by political knowledge, and vote preference, in the 1997-2001 British Election Panel Study"
#| label: fig-facetsfancylabels
#| warning: false

new_labels <- c(
  "0" = "No knowledge",
  "1" = "Low knowledge",
  "2" = "Moderate knowledge",
  "3" = "High knowledge"
)

beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(
    x = "Age-group of respondent",
    y = "Number of respondents",
    fill = "Voted for"
  ) +
  facet_wrap(
    vars(political.knowledge),
    dir = "v",
    scales = "free",
    labeller = labeller(political.knowledge = new_labels)
  ) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        legend.position = "bottom"
        )
```

This means that we now have three ways to have multiple graphs: sub-figures, facets, and `patchwork`. They are useful in different circumstances. For instance, we would often want to use sub-figures (covered in @sec-reproducible-workflows) when we are considering different variables, facets when considering different values of a categorical variable, and `patchwork` when interested in bringing together entirely different graphs.

We now turn to the colors used in the graph. There are a variety of different ways to change the colors. The many palettes available from `RColorBrewer` [@RColorBrewer], can be specified using `scale_fill_brewer()`, and in the case of `viridis` [@viridis], we can specify the palettes using `scale_fill_viridis()`. Additionally, `viridis` is particularly focused on color-blind palettes (@fig-usecolor).

::: callout-note
## Shoulders of giants

The name of the "brewer" palette refers to Cindy Brewer [@brewerisarealperson]. After earning a PhD in Geography from Michigan State University in 1991, she joined San Diego State University as an assistant professor, moving to Pennsylvania State University in 1994, where she was promoted to full professor in 2007. One of her best-known books is @brewerbook. In 2019 she became only the ninth person to have been awarded the O. M. Miller Cartographic Medal since it was established in 1968.
:::

```{r}
#| echo: true
#| eval: true
#| message: false
#| warning: false
#| fig-cap: "Distribution of age-group and vote preference, in the 1997-2001 British Election Panel Study, illustrating different colors"
#| label: fig-usecolor
#| fig-subcap: ["Brewer palette 'Blues'", "Brewer palette 'Set1'", "Viridis palette default", "Viridis palette 'magma'"]
#| layout-ncol: 2

library(viridis)

# Panel (a)
beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(x = "Age-group",
       y = "Number",
       fill = "Voted for") +
  theme(legend.position = "bottom") +
  scale_fill_brewer(palette = "Blues")

# Panel (b)
beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(x = "Age-group",
       y = "Number",
       fill = "Voted for") +
  theme(legend.position = "bottom") +
  scale_fill_brewer(palette = "Set1")

# Panel (c)
beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(x = "Age-group",
       y = "Number",
       fill = "Voted for") +
  theme(legend.position = "bottom") +
  scale_fill_viridis(discrete = TRUE)

# Panel (d)
beps |>
  ggplot(mapping = aes(x = age_group, fill = vote)) +
  geom_bar() +
  theme_minimal() +
  labs(x = "Age-group",
       y = "Number",
       fill = "Voted for") +
  theme(legend.position = "bottom") +
  scale_fill_viridis(discrete = TRUE,
                     option = "magma")
```

Finally, with increasing awareness of the issue, there are now many options for colorblind-friendly palettes. One that is well integrated with `ggplot2` is `scico` [@scico]. 

In addition to pre-built palettes, we can also build our own palette. That said, color is something to be considered with a great deal of care and it should only be used to increase the amount of information that is communicated [@elementsofgraphingdata]. Color should not be added to graphs unnecessarily---that is to say, it must play some role. Typically, that role is to distinguish different groups, which implies making the colors dissimilar. Color may also be appropriate if there is some relationship between the color and the variable, for instance if making a graph of the price of mangoes and raspberries, then it could help the reader if the colors were yellow and red, respectively [@franconeri2021science, p. 121].


### Scatterplots

We are often interested in the relationship between two numeric or continuous variables. We can use scatterplots to show this. Unless there is a good reason to move to a different option, a scatterplot is almost always the best choice [@weissgerber2015beyond]. Some consider it the most versatile and useful graph option [@historyofdataviz, p. 121] To illustrate scatterplots, we use `WDI` [@WDI] to download some economic indicators from the World Bank, and in particular `WDIsearch()` to find the unique key that we need to pass to `WDI()` to facilitate the download.

:::{.callout-note}
## Oh, you think we have good data on that!

Gross Domestic Product (GDP) "combines in a single figure, and with no double counting, all the output (or production) carried out by all the firms, non-profit institutions, government bodies and households in a given country during a given period, regardless of the type of goods and services produced, provided that the production takes place within the country's economic territory" [@EssentialMacroAggregates, p. 15]. The modern concept was developed by Simon Kuznets and is widely used and reported. There is a certain comfort in having a definitive and concrete single number to describe something as complicated as the entire economic activity of a country. And it is crucial that we have such summary statistics. But as with any summary statistic, its strength is also its weakness. A single number necessarily loses information about constituent components, and these distributional differences are critical. It highlights short term economic progress over longer term improvements. And "the quantitative definiteness of the estimates makes it easy to forget their dependence upon imperfect data and the consequently wide margins of possible error to which both totals and components are liable" [@NationalIncomeAndItsComposition, p. xxvi]. Reliance on any one summary measure of economic performance presents a misguided picture not only of a country's economy, but also of its peoples. There are clear areas where GDP needs to improve, including the health care sector and housing, as well as more disaggregated estimates [@Moyer2020Measuring]
:::

```{r}
#| echo: true
#| eval: false

install.packages("WDI")
```

```{r}
#| echo: true
#| eval: true

library(tidyverse)
library(WDI)

WDIsearch("gdp growth")
WDIsearch("inflation")
WDIsearch("population, total")
WDIsearch("Unemployment, total")
```

```{r}
#| echo: true
#| eval: false

world_bank_data <-
  WDI(
    indicator = c(
      "FP.CPI.TOTL.ZG",
      "NY.GDP.MKTP.KD.ZG",
      "SP.POP.TOTL",
      "SL.UEM.TOTL.NE.ZS"
    ),
    country = c("AU", "ET", "IN", "US")
  )
```

```{r}
#| echo: false
#| eval: false

# INTERNAL
write_csv(world_bank_data, "inputs/data/world_bank_data.csv")
```

```{r}
#| eval: true
#| warning: false
#| echo: false

# INTERNAL

world_bank_data <-
  read_csv(
    "inputs/data/world_bank_data.csv",
    show_col_types = FALSE
  )
```

We may like to change the names to be more meaningful, and only keep the columns that we need.

```{r}
#| echo: true
#| eval: true

world_bank_data <-
  world_bank_data |>
  rename(
    inflation = FP.CPI.TOTL.ZG,
    gdp_growth = NY.GDP.MKTP.KD.ZG,
    population = SP.POP.TOTL,
    unemployment_rate = SL.UEM.TOTL.NE.ZS
  ) |>
  select(country, year, inflation, gdp_growth, population, unemployment_rate)

head(world_bank_data)
```

To get started we can use `geom_point()` to make a scatterplot showing GDP growth and inflation, by country (@fig-scattorplot-1).

```{r}
#| warning: false
#| label: fig-scattorplot
#| fig-cap: "Relationship between inflation and GDP growth for Australia, Ethiopia, India, and the US"
#| fig-subcap: ["Default settings", "With the addition of a theme and labels", "Including standard errors"]
#| layout-ncol: 2

# Panel (a)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, y = inflation, color = country)) +
  geom_point()

# Panel (b)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, y = inflation, color = country)) +
  geom_point() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country",
    title = "Relationship between inflation and GDP growth",
    caption = "Data source: World Bank."
  )
```

As with bar charts, we change the theme, and update the labels (@fig-scattorplot-2), although we would normally not need both a caption and a title and would just use one.


Here we use "color" instead of "fill" because we are using dots rather than bars. This also then slightly affects how we change the palette (@fig-scatterplotnicercolor). 

```{r}
#| echo: true
#| eval: true
#| message: false
#| warning: false
#| label: fig-scatterplotnicercolor
#| fig-cap: "Relationship between inflation and GDP growth for Australia, Ethiopia, India, and the US"
#| fig-subcap: ["Brewer palette 'Blues'", "Brewer palette 'Set1'", "Viridis palette default", "Viridis palette 'magma'"]
#| layout-ncol: 2

# Panel (a)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, y = inflation, color = country)) +
  geom_point() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  ) +
  theme(legend.position = "bottom") +
  scale_color_brewer(palette = "Blues")

# Panel (b)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, y = inflation, color = country)) +
  geom_point() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  ) +
  theme(legend.position = "bottom") +
  scale_color_brewer(palette = "Set1")

# Panel (c)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, y = inflation, color = country)) +
  geom_point() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  ) +
  theme(legend.position = "bottom") +
  scale_colour_viridis_d()

# Panel (d)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, y = inflation, color = country)) +
  geom_point() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  ) +
  theme(legend.position = "bottom") +
  scale_colour_viridis_d(option = "magma")
```

The points of a scatterplot sometimes overlap. We can address this situation in a variety of ways (@fig-alphajitter): 

1) Adding a degree of transparency to our dots with "alpha" (@fig-alphajitter-1). The value for "alpha" can vary between 0, which is fully transparent, and 1, which is completely opaque. 
2) Adding a small amount of noise, which slightly moves the points, using `geom_jitter()` (@fig-alphajitter-2). By default, the movement is uniform in both directions, but we can specify which direction movement occurs with "width" or "height". The decision between these two options turns on the degree to which exact accuracy matters, and the number of points: it is often useful to use `geom_jitter()` when you want to highlight the relative density of points and not necessarily the exact value of individual points. When using `geom_jitter()` it is a good idea, for reproducibility, to set a seed.
3) Using `geom_beeswarm()` from `ggbeeswarm` [@ggbeeswarm] to attempt to add more information about the density than is available from a jittered graph (@fig-alphajitter-3).

```{r}
#| fig-cap: "Relationship between inflation and GDP growth for Australia, Ethiopia, India, and the US"
#| label: fig-alphajitter
#| warning: false
#| fig-subcap: ["Changing the alpha setting", "Using jitter", "Using beeswarm"]
#| layout-ncol: 2

library(ggbeeswarm)

set.seed(853)

# Panel (a)
world_bank_data |>
  ggplot(mapping = aes(
    x = gdp_growth,
    y = inflation,
    color = country
  )) +
  geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country",
    caption = "Data source: World Bank."
  )

# Panel (b)
world_bank_data |>
  ggplot(mapping = aes(
    x = gdp_growth,
    y = inflation,
    color = country
  )) +
  geom_jitter(width = 0.4, height = 0.4) +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country",
    caption = "Data source: World Bank."
  )

# Panel (c)
world_bank_data |>
  ggplot(mapping = aes(
    x = gdp_growth,
    y = inflation,
    color = country
  )) +
  geom_beeswarm() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country",
    caption = "Data source: World Bank."
  )
```

A common use case for a scatterplot is to illustrate a relationship between two continuous variables. It can be useful to add a line of best fit using `geom_smooth()` (@fig-scattorplottwo). By default, `geom_smooth()` will use locally estimated scatterplot smoothing (LOESS) for datasets with less than 1,000 observations, but we can specify the relationship using "method", change the color with "color" and add or remove standard errors with "se". A commonly used "method" is `lm`, which computes and plots a simple linear regression line similar to using the `lm()` function [@citeR]. Using `geom_smooth()` adds a layer to the graph, and so it inherits aesthetics from `ggplot()`. For instance, that is why we have one line for each country in @fig-scattorplottwo-1 and @fig-scattorplottwo-2. We could overwrite that by specifying a particular color (@fig-scattorplottwo-3). There are situation where other types of fitted lines might be preferred, such as splines.

```{r}
#| message: false
#| warning: false
#| fig-cap: "Relationship between inflation and GDP growth for Australia, Ethiopia, India, and the US"
#| label: fig-scattorplottwo
#| fig-subcap: ["Default line of best fit", "Specifying a linear relationship", "Specifying only one color"]
#| layout-ncol: 2

# Panel (a)
world_bank_data |>
  ggplot(mapping = aes(
    x = gdp_growth,
    y = inflation,
    color = country
  )) +
  geom_jitter() +
  geom_smooth() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  )

# Panel (b)
world_bank_data |>
  ggplot(mapping = aes(
    x = gdp_growth,
    y = inflation,
    color = country
  )) +
  geom_jitter() +
  geom_smooth(method = lm, se = FALSE) +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  )

# Panel (c)
world_bank_data |>
  ggplot(mapping = aes(
    x = gdp_growth,
    y = inflation,
    color = country
  )) +
  geom_jitter() +
  geom_smooth(method = lm, color = "black", se = FALSE) +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Inflation",
    color = "Country"
  )
```


### Line plots

We can use a line plot when we have variables that should be joined together, for instance, an economic time series. We will continue with the dataset from the World Bank and focus on US GDP growth using `geom_line()` (@fig-lineplot). 

```{r}
#| fig-cap: "US GDP growth (1961-2020)"
#| label: fig-lineplot
#| warning: false

world_bank_data |>
  filter(country == "United States") |>
  ggplot(mapping = aes(x = year, y = gdp_growth)) +
  geom_line()
```

As before, we can adjust the theme, say with `theme_minimal()` and labels with `labs()` (@fig-lineplottwo).

```{r}
#| fig-cap: "US GDP growth (1961-2020)"
#| label: fig-lineplottwo
#| warning: false

world_bank_data |>
  filter(country == "United States") |>
  ggplot(mapping = aes(x = year, y = gdp_growth)) +
  geom_line() +
  theme_minimal() +
  labs(
    x = "Year",
    y = "GDP growth",
    caption = "Data source: World Bank."
  )
```

We can use `geom_step()`, a slight variant of `geom_line()`, to focus attention on the change from year to year (@fig-stepplot).

```{r}
#| fig-cap: "US GDP growth (1961-2020)"
#| label: fig-stepplot
#| warning: false

world_bank_data |>
  filter(country == "United States") |>
  ggplot(mapping = aes(x = year, y = gdp_growth)) +
  geom_step() +
  theme_minimal() +
  labs(
    x = "Year",
    y = "GDP growth",
    caption = "Data source: World Bank."
  )
```

The Phillips curve is the name given to plot of the relationship between unemployment and inflation over time. An inverse relationship is sometimes found in the data, for instance in the UK between 1861 and 1957 [@phillips1958relation]. We have a variety of ways to investigate this relationship in our data, including:

1) Adding a second line to our graph. For instance, we could add inflation (@fig-notphillips). This may require us to use `pivot_longer()` to ensure that the data are in tidy format.
2) Using `geom_path()` to links values in the order they appear in the dataset. In @fig-phillipsmyboy we show a Phillips curve for the US between 1960 and 2020. @fig-phillipsmyboy does not appear to show any clear relationship between unemployment and inflation.

```{r}
#| fig-cap: "Unemployment and inflation for the US (1960-2020)"
#| label: fig-notphillips
#| warning: false

world_bank_data |>
  filter(country == "United States") |>
  select(-population, -gdp_growth) |>
  pivot_longer(
    cols = c("inflation", "unemployment_rate"),
    names_to = "series",
    values_to = "value"
  ) |>
  ggplot(mapping = aes(x = year, y = value, color = series)) +
  geom_line() +
  theme_minimal() +
  labs(
    x = "Year",
    y = "Value",
    color = "Economic indicator",
    caption = "Data source: World Bank."
  ) +
  scale_color_brewer(
    palette = "Set1",
    labels = c("Inflation", "Unemployment")
  ) +
  theme(legend.position = "bottom")
```


```{r}
#| fig-cap: "Phillips curve for the US (1960-2020)"
#| label: fig-phillipsmyboy
#| warning: false

world_bank_data |>
  filter(country == "United States") |>
  ggplot(mapping = aes(x = unemployment_rate, y = inflation)) +
  geom_path() +
  theme_minimal() +
  labs(
    x = "Unemployment rate",
    y = "Inflation",
    caption = "Data source: World Bank."
  )
```

### Histograms

A histogram is useful to show the shape of the distribution of a continuous variable. They construct counts of the number of observations in different subsets of the support, called "bins". In @fig-hisogramone we examine the distribution of GDP in Ethiopia, and we can add a theme and labels.

```{r}
#| fig-cap: "Distribution of GDP growth in Ethiopia (1960-2020)"
#| label: fig-hisogramone
#| message: false
#| warning: false

world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram() +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Number of occurrences",
    caption = "Data source: World Bank."
  )
```

The key component determining the shape of a histogram is the number of bins. This can be specified in one of two ways (@fig-hisogrambins): 

1) specifying the number of "bins" to include, or 
2) specifying how wide they should be, "binwidth".

```{r}
#| message: false
#| warning: false
#| fig-cap: "Distribution of GDP growth in Ethiopia (1960-2020)"
#| label: fig-hisogrambins
#| fig-subcap: ["Two bins", "Five bins", "20 bins", "0.5 binwidth", "2 binwidth", "5 binwidth"]
#| layout-ncol: 2

# Panel (a)
world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram(bins = 2) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences"
  )

# Panel (b)
world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram(bins = 5) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences"
  )

# Panel (c)
world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram(bins = 20) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences"
  )

# Panel (d)
world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram(binwidth = 0.5) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences"
  )

# Panel (e)
world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram(binwidth = 2) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences"
  )

# Panel (f)
world_bank_data |>
  filter(country == "Ethiopia") |>
  ggplot(mapping = aes(x = gdp_growth)) +
  geom_histogram(binwidth = 5) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences"
  )
```

Histograms smooth data, and the number of bins affects how much smoothing occurs. When there are only two bins then the data are very smooth, but we lose a great deal of accuracy. More specifically, "the histogram estimator is a piecewise constant function where the height of the function is proportional to the number of observations in each bin" [@wasserman, p. 303]. Too few bins result in a biased estimator, while too many bins results in an estimator with high variance. Our decision as to the number of bins, or their width, is concerned with trying to balance bias and variance. This will depend on a variety of concerns including the subject matter and the goal [@elementsofgraphingdata, p. 135].

Finally, while we can use "fill" to distinguish between different types of observations, it can get quite messy. It is usually better to: 1) give away showing the distribution with columns and instead trace the outline of the distribution using `geom_freqpoly()` (@fig-different-obs-1) to build it up using dots with `geom_dotplot()` (@fig-different-obs-2); or 3) add transparency, especially if the differences are more stark (@fig-different-obs-3).

```{r}
#| fig-cap: "Distribution of GDP growth in four countries (1960-2020)"
#| label: fig-different-obs
#| message: false
#| warning: false
#| layout-ncol: 2
#| fig-subcap: ["Tracing the outline", "Using dots", "Adding transparency", "ECDF"]

# Panel (a)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, color = country)) +
  geom_freqpoly() +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences",
    color = "Country",
    caption = "Data source: World Bank."
  ) +
  scale_color_brewer(palette = "Set1")

# Panel (b)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, group = country, fill = country)) +
  geom_dotplot(method = "histodot") +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences",
    fill = "Country",
    caption = "Data source: World Bank."
  ) +
  scale_color_brewer(palette = "Set1")

# Panel (c)
world_bank_data |>
  filter(country %in% c("India", "United States")) |>
  ggplot(mapping = aes(x = gdp_growth, fill = country)) +
  geom_histogram(alpha = 0.5) +
  theme_minimal() +
  labs(
    x = "GDP",
    y = "Number of occurrences",
    color = "Country",
    caption = "Data source: World Bank."
  ) +
  scale_color_brewer(palette = "Set1")

# Panel (d)
world_bank_data |>
  ggplot(mapping = aes(x = gdp_growth, color = country)) +
  stat_ecdf(geom = "point") +
  theme_minimal() +
  labs(
    x = "GDP growth",
    y = "Proportion",
    color = "Country",
    caption = "Data source: World Bank."
  )
```

An interesting alternative to a histogram is the empirical cumulative distribution function (ECDF). The choice between this and a histogram is largely audience-specific. It is not appropriate for less-sophisticated audiences, but if the audience is quantitatively competent, then it can be a great choice because it does less smoothing than a histogram. We can build an ECDF with `stat_ecdf()`. For instance, @fig-different-obs-4 shows an ECDF equivalent to @fig-hisogramone.

### Boxplots

One reason for using graphs is that they help us understand and embrace how complex our data are, rather than trying to hide and smooth it away [@armstrongembracecomplexity]. As such, boxplots are almost never an appropriate choice because they hide the distribution of data, rather than show it. Unless we need to compare the summary statistics of many variables at once, then they should almost never be used (an example of this exception is @Bethlehem2022). This is because the same boxplot can apply to very different distributions. To see this, consider some simulated data from the beta distribution of two types. One type of data contains draws from two beta distributions: one that is right skewed and another that is left skewed. The other type of data contains draws from a beta distribution with no skew, noting that $\mbox{Beta}(1, 1)$ is equivalent to $\mbox{Uniform}(1, 1)$.

```{r}
set.seed(853)

number_of_draws <- 10000

both_left_and_right_skew <-
  c(
    rbeta(number_of_draws / 2, 5, 2),
    rbeta(number_of_draws / 2, 2, 5)
  )

no_skew <-
  rbeta(number_of_draws, 1, 1)

beta_distributions <-
  tibble(
    observation = c(both_left_and_right_skew, no_skew),
    source = c(
      rep("Left and right skew", number_of_draws),
      rep("No skew", number_of_draws)
    )
  )
```

We can first compare the boxplots of the two series (@fig-boxplotfirst-1). But if we plot the actual data then we can see how different they are (@fig-boxplotfirst-2).

```{r}
#| label: fig-boxplotfirst
#| message: false
#| warning: false
#| layout-ncol: 2
#| fig-cap: "Data drawn from beta distributions with different parameters"
#| fig-subcap: ["Illustrated with a boxplot","Actual data"]

beta_distributions |>
  ggplot(aes(x = source, y = observation)) +
  geom_boxplot() +
  theme_classic()

beta_distributions |>
  ggplot(aes(x = observation, color = source)) +
  geom_freqpoly(binwidth = 0.05) +
  theme_classic()
```

One way forward, if a boxplot must be included, is to include the actual data as a layer on top of the boxplot. For instance, in @fig-bloxplotandoverlay we show the distribution of inflation across the four countries. The reason that this works well is that it shows the data in greater fidelity. In general, better alternatives would be those that we covered earlier in this chapter, including bar charts, scatterplots, line plots and histograms. Violin plots, although beyond the scope of this book, are good alternative as well, and are included in `ggplot2` with `geom_violin()`.

```{r}
#| fig-cap: "Distribution of unemployment data for four countries (1960-2020)"
#| label: fig-bloxplotandoverlay
#| message: false
#| warning: false

world_bank_data |>
  ggplot(mapping = aes(x = country, y = inflation)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.3, width = 0.15, height = 0) +
  theme_minimal() +
  labs(
    x = "Country",
    y = "Inflation",
    caption = "Data source: World Bank."
  ) +
  scale_color_brewer(palette = "Set1")
```



## Tables

Tables are critical for telling a compelling story. Tables can communicate less information than a graph, but they do so at a high fidelity. For instance, @andersen2021presenting say that tables are especially useful to highlight a few specific values. We primarily use tables in three ways:

1. To show some of our actual dataset, for which we use `kable()` from `knitr` [@citeknitr], alongside `kableExtra` [@citekableextra].
2. To communicate summary statistics, for which we use `modelsummary` [@citemodelsummary].
3. To display regression results, for which we also use `modelsummary` [@citemodelsummary].

It is worth pointing out that even for many of these applications, a graph may be a better choice, albeit one that requires more effort on the part of the author [@Kastellec2007].


### Showing part of a dataset

We illustrate showing part of a dataset using `kable()` from `knitr` and drawing on `kableExtra` for enhancement. We use the World Bank dataset that we downloaded earlier.

```{r}
library(knitr)
head(world_bank_data)
```

To begin, we can display the first ten rows with the default `kable()` settings.

```{r}
world_bank_data |>
  slice(1:10) |>
  kable()
```


To be able to cross-reference it in the text, we need to add a caption to the R chunk. We can also make the column names more information with "col.names" and specify the number of digits to be displayed (@tbl-gdpfirst).

```{r}
#| label: tbl-gdpfirst
#| message: false
#| tbl-cap: "First ten rows of a dataset of economic indicators for Australia, Ethiopia, India, and the US"

world_bank_data |>
  slice(1:10) |>
  kable(
    col.names = c(
      "Country",
      "Year",
      "Inflation",
      "GDP growth",
      "Population",
      "Unemployment rate"
    ),
    digits = 1
  )
```


### Improving the formatting

When producing PDFs, the "booktabs" option makes a host of small changes to the default display and results in tables that look better (@tbl-gdpbookdtabs). When using "booktabs" we additionally should specify "linesep" otherwise `kable()` adds a small space every five lines. (None of this will show up for html output.)

```{r}
#| label: tbl-gdpbookdtabs
#| message: false
#| tbl-cap: "First ten rows of a dataset of economic indicators for Australia, Ethiopia, India, and the US"

world_bank_data |>
  slice(1:10) |>
  kable(
    col.names = c(
      "Country",
      "Year",
      "Inflation",
      "GDP growth",
      "Population",
      "Unemployment rate"
    ),
    digits = 1,
    booktabs = TRUE,
    linesep = ""
  )
```

```{r}
#| label: tbl-gdpbookdtabsnolinesep
#| message: false
#| tbl-cap: "First ten rows of a dataset of economic indicators for Australia, Ethiopia, India, and the US"

world_bank_data |>
  slice(1:10) |>
  kable(
    col.names = c(
      "Country",
      "Year",
      "Inflation",
      "GDP growth",
      "Population",
      "Unemployment rate"
    ),
    digits = 1,
    booktabs = TRUE
  )
```


We specify the alignment of the columns using a character vector of "l" (left), "c" (center), and "r" (right) (@tbl-gdpalign). Additionally, we can change the formatting. For instance, we could specify groupings for numbers that are at least one thousand using "format.args = list(big.mark = ",")".

```{r}
#| label: tbl-gdpalign
#| message: false
#| tbl-cap: "First ten rows of a dataset of economic indicators for Australia, Ethiopia, India, and the US"

world_bank_data |>
  slice(1:10) |>
  mutate(year = as.factor(year)) |>
  kable(
    col.names = c(
      "Country",
      "Year",
      "Inflation",
      "GDP growth",
      "Population",
      "Unemployment rate"
    ),
    digits = 1,
    booktabs = TRUE,
    linesep = "",
    align = c("l", "l", "c", "c", "r", "r"),
    format.args = list(big.mark = ",")
  )
```

We can use `kableExtra` [@citekableextra] to add extra functionality to `kable`. For instance, we could add a row that groups some of the columns using `add_header_above()` (@tbl-gdpkableextra). This impacts the spacing of the table, so we can also specify `kable_styling(full_width = TRUE)` to make sure that the table still fills the full width of our document.

```{r}
#| label: tbl-gdpkableextra
#| message: false
#| tbl-cap: "Economic indicators for Australia, Ethiopia, India, and the US"

library(kableExtra)

world_bank_data |>
  slice(1:10) |>
  kable(
    col.names = c(
      "Country",
      "Year",
      "Inflation",
      "GDP growth",
      "Population",
      "Unemployment rate"
    ),
    digits = 1,
    booktabs = TRUE,
    linesep = "",
    align = c("l", "l", "c", "c", "r", "r"),
  ) |>
  add_header_above(c(" " = 2, "Economic indicators" = 4)) |>
  kable_styling(full_width = TRUE)
```



Another especially nice way to build tables is to use `gt` [@citegt].

```{r}
#| label: gtfirst

library(gt)

world_bank_data |>
  slice(1:10) |>
  gt()
```

We can add a caption and more informative column labels (@tbl-dsdfweasdf).

```{r}
#| label: tbl-dsdfweasdf
#| tbl-cap: "First ten rows of a dataset of economic indicators for Australia, Ethiopia, India, and the US"

world_bank_data |>
  slice(1:10) |>
  gt() |>
  cols_label(
    country = "Country",
    year = "Year",
    inflation = "Inflation",
    gdp_growth = "GDP growth",
    population = "Population",
    unemployment_rate = "Unemployment rate"
  )
```


### Communicating summary statistics

We can use `datasummary()` from `modelsummary` to create tables of summary statistics from our dataset. 

::: {.content-visible when-format="pdf"}

We remove "population" for reasons of space.

```{r}
#| message: false
#| warning: false

library(modelsummary)

world_bank_data |>
  select(-population) |>
  rename(unem_rate = unemployment_rate) |> 
  datasummary_skim(histogram = FALSE)
```
:::

::: {.content-visible unless-format="pdf"}
```{r}
#| message: false
#| warning: false

library(modelsummary)

world_bank_data |>
  datasummary_skim()
```
:::

By default, `datasummary()` summarizes the "numeric" variables, but we can ask for the "categorical" variables (@tbl-testdatasummary). Additionally we can add cross-references in the same way as `kable()`, that is, include a title and then cross-reference the name of the R chunk.

```{r}
#| label: tbl-testdatasummary
#| tbl-cap: "Summary of categorical economic indicator variables for four countries"

world_bank_data |>
  datasummary_skim(type = "categorical")
```

We can create a table that shows the correlation between variables using `datasummary_correlation()` (@tbl-correlationtable).

```{r}
#| label: tbl-correlationtable
#| tbl-cap: "Correlation between the economic indicator variables for four countries (Australia, Ethiopia, India, and the US)"

world_bank_data |>
  rename(unem_rate = unemployment_rate) |> 
  datasummary_correlation()
```

We typically need a table of descriptive statistics that we could add to our paper (@tbl-descriptivestats). This contrasts with @tbl-testdatasummary which would likely not be included in a paper. We can add a note about the source of the data using `notes`.

```{r}
#| label: tbl-descriptivestats
#| warning: false
#| tbl-cap: "Descriptive statistics for the inflation and GDP dataset"

datasummary_balance(
  formula = ~country,
  data = world_bank_data |> filter(country %in% c("Australia", "Ethiopia")),
  dinm = FALSE,
  notes = "Data source: World Bank."
)
```





### Display regression results

Finally, one common reason for needing a table is to report regression results. We will do this using `modelsummary()` from `modelsummary` [@citemodelsummary]. For instance, we could display the estimates from a few different models [@tbl-twomodels].

```{r}
#| label: tbl-twomodels
#| tbl-cap: "Explaining GDP as a function of inflation"

first_model <- lm(
  formula = gdp_growth ~ inflation,
  data = world_bank_data
)

second_model <- lm(
  formula = gdp_growth ~ inflation + country,
  data = world_bank_data
)

third_model <- lm(
  formula = gdp_growth ~ inflation + country + population,
  data = world_bank_data
)

modelsummary(list(first_model, second_model, third_model))
```

We can adjust the number of significant digits (@tbl-twomodelstwo). This is a critical aspect of establishing credibility. It is certainly not the case that we should just naively add as many significant digits as possible [@howes2022representing]. Instead, we should think carefully about the data generating process that we have access to and adjust our significant digits appropriately.

```{r}
#| label: tbl-twomodelstwo
#| tbl-cap: "Two models of GDP as a function of inflation"

modelsummary(
  list(first_model, second_model, third_model),
  fmt = 1
)
```





## Maps

In many ways maps can be thought of as another type of graph, where the x-axis is latitude, the y-axis is longitude, and there is some outline or a background image. It is possible they are the oldest and best understood type of chart [@karsetn, p. 1].

```{r}
#| eval: false

ggplot() +
  geom_polygon(
    # First draw an outline
    data = some_data,
    aes(
      x = latitude,
      y = longitude,
      group = group
    )
  ) +
  geom_point(
    # Then add points of interest
    data = some_other_data,
    aes(
      x = latitude,
      y = longitude
    )
  )
```

And while there are some small complications, for the most part it is as straight-forward as that. The first step is to get some data. There is some geographic data built into `ggplot2`, and there is additional information in the "world.cities" dataset from `maps`. 

```{r}
#| message: false
#| warning: false

library(maps)

france <- map_data(map = "france")

head(france)

french_cities <-
  world.cities |>
  filter(country.etc == "France")

head(french_cities)
```

With that information in hand, we can then create a map of France that shows the larger cities (@fig-heyitsfrance). We use `geom_polygon()` from `ggplot2` to draw shapes by connecting points within groups. And `coord_map()` adjusts for the fact that we are making a 2D map to represent a world that is 3D.

```{r}
#| label: fig-heyitsfrance
#| fig-cap: "Map of France showing the largest cities"
#| message: false
#| warning: false

ggplot() +
  geom_polygon(
    data = france,
    aes(
      x = long,
      y = lat,
      group = group
    ),
    fill = "white",
    colour = "grey"
  ) +
  coord_map() +
  geom_point(
    aes(
      x = french_cities$long,
      y = french_cities$lat
    ),
    alpha = 0.3,
    color = "black"
  ) +
  theme_classic() +
  labs(
    x = "Longitude",
    y = "Latitude"
  )
```

As is often the case with R, there are many ways to get started creating static maps. We have seen how they can be built using only `ggplot2`, but `ggmap` brings additional functionality [@KahleWickham2013].

There are two essential components to a map: 

1) a border or background image (sometimes called a tile); and 
2) something of interest within that border, or on top of that tile. 

In `ggmap`, we use an open-source option for our tile, Stamen Maps. And we use plot points based on latitude and longitude.


### Australian polling places

In Australia people go to specific locations, called booths, to vote. Because the booths have coordinates (latitude and longitude), we can plot them in a map. One reason we may like to plot the location of the booth is to notice voting patterns over geographies.

To get started we need to get a tile. We are going to use `ggmap` to get a tile from Stamen Maps, which builds on [OpenStreetMap](openstreetmap.org). The main argument to this function is to specify a bounding box. This requires two latitudes - one for the top of the box and one for the bottom of the box - and two longitudes - one for the left of the box and one for the right of the box. It can be useful to use Google Maps, or other mapping platform, to find the coordinate values that you need. The bounding box provides the coordinates of the edges that you are interested in. In this case we have provided it with coordinates such that it will be centered around Canberra, Australia, which is a small city that was created for the purposes of being the capital.

```{r}
#| warning: false
#| message: false

library(ggmap)

bbox <- c(left = 148.95, bottom = -35.5, right = 149.3, top = -35.1)
```

Once you have defined the bounding box, then the function `get_stamenmap()` will get the tiles in that area (@fig-heyitscanberra). The number of tiles that it needs to get depends on the zoom, and the type of tiles that it gets depends on the type of map. We have used a black-and-white type of map but there are others including color and terrain. At this point we can pass the tiles to `ggmap()` and it will plot the tiles. You need an internet connection for this to work as `get_stamenmap()` will be actively downloading these tiles.

```{r}
#| label: fig-heyitscanberra
#| fig-cap: "Map of Canberra, Australia"
#| warning: false
#| message: false

canberra_stamen_map <- get_stamenmap(bbox, 
                                     zoom = 11, 
                                     maptype = "toner-lite")

ggmap(canberra_stamen_map)
```

Once we have a map then we can use `ggmap()` to plot it. Now we want to get some data that we plot on top of our tiles. We will plot the location of the polling place based on its "division". This is available [from the Australian Electoral Commission (AEC)](https://results.aec.gov.au/20499/Website/Downloads/HouseTppByPollingPlaceDownload-20499.csv), which is the government agency that is responsible for elections in Australia.

::: {.content-visible when-format="pdf"}
```{r}
#| warning: false
#| message: false

# Read in the booths data for each year
booths <-
  readr::read_csv(
    paste0(
      "https://results.aec.gov.au/24310/Website/Downloads/",
      "GeneralPollingPlacesDownload-24310.csv"
    ),
    skip = 1,
    guess_max = 10000
  )

head(booths)
```
:::

::: {.content-visible unless-format="pdf"}
```{r}
#| warning: false
#| message: false

# Read in the booths data for each year
booths <-
  readr::read_csv(
    "https://results.aec.gov.au/24310/Website/Downloads/GeneralPollingPlacesDownload-24310.csv",
    skip = 1,
    guess_max = 10000
  )

head(booths)
```
:::

This dataset is for the whole of Australia, but as we are only plotting the area around Canberra, we will filter the data to only booths with a geography close to Canberra.

```{r}
#| warning: false
#| message: false

# Reduce to only rows with latitude and longitude
booths_reduced <-
  booths |>
  filter(State == "ACT") |>
  select(PollingPlaceID, DivisionNm, Latitude, Longitude) |>
  filter(!is.na(Longitude)) |> # Remove rows without geography
  filter(Longitude < 165) # Remove Norfolk Island
```

Now we can use `ggmap` in the same way as before to plot our underlying tiles, and then build on that using `geom_point()` to add our points of interest.

```{r}
#| label: fig-heyitscanberrapolling
#| fig-cap: "Map of Canberra, Australia, with polling places"
#| warning: false
#| message: false

ggmap(
  canberra_stamen_map,
  extent = "normal",
  maprange = FALSE
) +
  geom_point(
    data = booths_reduced,
    aes(
      x = Longitude,
      y = Latitude,
      colour = DivisionNm
    )
  ) +
  scale_color_brewer(name = "2019 Division", palette = "Set1") +
  coord_map(
    projection = "mercator",
    xlim = c(attr(map, "bb")$ll.lon, attr(map, "bb")$ur.lon),
    ylim = c(attr(map, "bb")$ll.lat, attr(map, "bb")$ur.lat)
  ) +
  labs(
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
```

We may like to save the map so that we do not have to draw it every time, and we can do that in the same way as any other graph, using `ggsave()`.

```{r}
#| eval: false

ggsave("map.pdf", width = 20, height = 10, units = "cm")
```

Finally, the reason that we used Stamen Maps and OpenStreetMap is because it is open source, but we could have also used Google Maps. This requires you to first register a credit card with Google, and specify a key, but with low usage the service should be free. Using Google Maps, by using `get_googlemap()` within `ggmap` brings some advantages over `get_stamenmap()`, for instance it will attempt to find a placename rather than needing to specify a bounding box.



### US troop deployment

Let us see another example of a static map, this time using data on US military deployments from `troopdata` [@troopdata]. We can access data about US overseas military bases back to the start of the Cold War using `get_basedata()`.

```{r}
#| eval: false

install.packages("troopdata")
```

```{r}
library(troopdata)

bases <- get_basedata()

head(bases)
```

We will look at the locations of US military bases in: Germany, Japan, and Australia. The `troopdata` dataset already has the latitude and longitude of each base, and we will use that as our item of interest. The first step is to define a bounding box for each of country.

```{r}
#| message: false
#| warning: false

library(ggmap)

# From: https://data.humdata.org/dataset/bounding-boxes-for-countries
bbox_germany <-
  c(
    left = 5.867,
    bottom = 45.967,
    right = 15.033,
    top = 55.133
  )

bbox_japan <-
  c(
    left = 127,
    bottom = 30,
    right = 146,
    top = 45
  )

bbox_australia <-
  c(
    left = 112.467,
    bottom = -45,
    right = 155,
    top = -9.133
  )
```

Then we need to get the tiles using `get_stamenmap()` from `ggmap`. 

```{r}
#| message: false
#| warning: false

germany_stamen_map <-
  get_stamenmap(bbox_germany, zoom = 6, maptype = "toner-lite")

japan_stamen_map <-
  get_stamenmap(bbox_japan, zoom = 6, maptype = "toner-lite")

australia_stamen_map <-
  get_stamenmap(bbox_australia, zoom = 5, maptype = "toner-lite")
```

And finally, we can bring it all together with maps showing US military bases in Germany (@fig-mapbasesingermany), Japan (@fig-mapbasesinjapan), and Australia (@fig-mapbasesinaustralia).

```{r}
#| fig-cap: "Map of US military bases in Germany"
#| label: fig-mapbasesingermany
#| message: false
#| warning: false

ggmap(germany_stamen_map) +
  geom_point(
    data = bases,
    aes(
      x = lon,
      y = lat
    )
  ) +
  labs(
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal()
```

```{r}
#| fig-cap: "Map of US military bases in Japan"
#| label: fig-mapbasesinjapan
#| message: false
#| warning: false

ggmap(japan_stamen_map) +
  geom_point(
    data = bases,
    aes(
      x = lon,
      y = lat
    )
  ) +
  labs(
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal()
```


```{r}
#| fig-cap: "Map of US military bases in Australia"
#| label: fig-mapbasesinaustralia
#| message: false
#| warning: false

ggmap(australia_stamen_map) +
  geom_point(
    data = bases,
    aes(
      x = lon,
      y = lat
    )
  ) +
  labs(
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal()
```





### Geocoding

So far we have assumed that we already had geocoded data, which means that we have latitude and longitude coordinates for each place. But sometimes we only have place names, such as "Sydney, Australia", "Toronto, Canada", "Accra, Ghana", "Guayaquil, Ecuador". Before we can plot them, we need to get latitude and longitude coordinates in each case. The process of going from names to coordinates is called geocoding.

:::{.callout-note}
## Oh, you think we have good data on that!

While you almost surely know where you live, it can be surprisingly difficult to specifically define the boundaries of many places. And this is made especially difficult when different levels of government have different definitions. @bronnerquantediting illustrates this in the case of Atlanta, Georgia, where there are (at least) three official different definitions: 1) the metropolitan statistical area; 2) the urbanized area; and 3) the census place. She points out that which definition is used will have a substantial effect on the result of any analysis, or even the data that are available, even though they are all unimpeachably about Atlanta. 
:::

There are a range of options to geocode data in R, but `tidygeocoder` is especially useful [@citetidygeocoder]. We first need a dataframe of locations. 

```{r}
place_names <-
  tibble(
    city = c("Sydney", "Toronto", "Accra", "Guayaquil"),
    country = c("Australia", "Canada", "Ghana", "Ecuador")
  )

place_names
```

```{r}
#| message: false
#| warning: false

library(tidygeocoder)

place_names <-
  geo(
    city = place_names$city,
    country = place_names$country,
    method = "osm"
  )

place_names
```

And we can now plot and label these cities (@fig-mynicemap).

```{r}
#| fig-cap: "Map of Accra, Sydney, Toronto, and Guayaquil after geocoding to obtain their locations"
#| label: fig-mynicemap
#| message: false
#| warning: false

world <- map_data(map = "world")

ggplot() +
  geom_polygon(
    data = world,
    aes(
      x = long,
      y = lat,
      group = group
    ),
    fill = "white",
    colour = "grey"
  ) +
  coord_map(ylim = c(47, -47)) +
  geom_point(
    aes(
      x = place_names$long,
      y = place_names$lat
    ),
    color = "black"
  ) +
  geom_text(
    aes(
      x = place_names$long,
      y = place_names$lat,
      label = place_names$city
    ),
    nudge_y = -5
  ) +
  theme_classic() +
  labs(
    x = "Longitude",
    y = "Latitude"
  )
```


## Concluding remarks

In this chapter we have covered a lot of ground, focused on communicating data. We spent a lot of time on graphs, because of their ability to convey a large amount of information in an efficient way. We then turned to tables because of how they can specifically convey information. Finally, we discussed maps, which allow us to display geographic information. The most important task is to show the actual data to the full extent possible.

## Exercises

### Scales {.unnumbered}

1. *(Plan)* Consider the following scenario: *Five friends---Ash, Jacki, Matt, Mike, and Rol---each measure the height of 20 of their friends. Each of the five use a slightly different approach to measurement and so make slightly different errors.* Please sketch out what that dataset could look like and then sketch a graph that you could build to show all observations.
2. *(Simulate)* Please further consider the scenario described and simulate the situation with every variable independent of each other. Please include three tests based on the simulated data.
3. *(Acquire)* Please describe a possible source of such a dataset.
4. *(Explore)* Please use `ggplot2` to build the graph that you sketched using the data that you simulated.
5. *(Communicate)* Please write two paragraphs about what you did.

### Questions {.unnumbered}

1. Assume `tidyverse` and `datasauRus` are installed and loaded. What would be the outcome of the following code?
`datasaurus_dozen |> filter(dataset == "v_lines") |> ggplot(aes(x=x, y=y)) + geom_point()`
    a.  Four vertical lines
    b. Five vertical lines
    c. Three vertical lines
    d. Two vertical lines
2. Assume `tidyverse` and the "beps" dataset have been installed and loaded. Which argument should be added to `geom_bar()` in the following code to make the bars for the different parties be next to each other rather than on top of each other?
`beps |> ggplot(mapping = aes(x = age, fill = vote)) + geom_bar()`
    a. `position = "side_by_side"`
    b.  `position = "dodge"`
    c. `position = "adjacent"`
    d. `position = "closest"`
3. Which theme does not have solid lines along the x and y axes (pick one)?
    a.  `theme_minimal()`
    b. `theme_classic()`
    c. `theme_bw()`
4. Assume `tidyverse` and the "beps" dataset have been installed and loaded. What should be added to `labs()` to change the text of the legend?
`beps |> ggplot(mapping = aes(x = age, fill = vote)) + geom_bar() + theme_minimal() + labs(x = "Age of respondent", y = "Number of respondents")`
    a. `color = "Voted for"`
    b. `legend = "Voted for"`
    c. `scale = "Voted for"`
    d.  `fill = "Voted for"`
5. Which palette from `?scale_colour_brewer()` is diverging (hint: read the help)?
    a. "Accent"
    b.  "RdBu"
    c. "GnBu"
    d. "Set1"
6. Which geom should be used to make a scatter plot?
    a. `geom_smooth()`
    b.  `geom_point()`
    c. `geom_bar()`
    d. `geom_dotplot()`
7. Which of these would result in the largest number of bins?
    a. `geom_histogram(binwidth = 5)`
    b.  `geom_histogram(binwidth = 2)`
8. Suppose there is a dataset that contains the heights of 100 birds, each from one of three different species. If we are interested in understanding the distribution of these heights, then in a paragraph or two, please explain which type of graph should be used and why.
10. Assume the dataset and columns exist. Would this code work? `data |> ggplot(aes(x = col_one)) |> geom_point()` (pick one)?
    a. Yes
    b.  No
9. Which geom should be used to plot categorical data (pick one)?
    a.  `geom_bar()`
    b. `geom_point()`
    c. `geom_abline()`
    d. `geom_boxplot()`
10. Why are boxplots often inappropriate (pick one)?
    a.  They hide the distribution of the data.
    b. They are hard to make.
    c. They are ugly.
    d. The mode is clearly displayed.
11. Which of the following, if any, are elements of the layered grammar of graphics [@wickham2010layered] (select all that apply)?
    a. A default dataset and set of mappings from variables to aesthetics.
    b. One or more layers, with each layer having one geometric object, one statistical transformation, one position adjustment, and optionally, one dataset and set of aesthetic mappings.
    c. Colors that enable the reader to understand the main point.
    d. A coordinate system.
    e. The facet specification.
    f. One scale for each aesthetic mapping used.
12. Which function from `modelsummary` is used to create a table of descriptive statistics?
    a. `datasummary_descriptive()`
    b. `datasummary_skim()`
    c. `datasummary_crosstab()`
    d.  `datasummary_balance()`


### Tutorial {.unnumbered}

Use Quarto, and include an appropriate title, author, date, and citations. Submit a PDF.

Please create a graph using `ggplot2` and a map using `ggmap` and add explanatory text to accompany both. Be sure to include cross-references and captions, etc. Each of these should take about pages.

Then, with regard the graph you created, please reflect on @vanderplas2020testing and add a few paragraphs about the different options that you considered that the graph more effective. If you have not now got at least two pages for each, then you have likely written too little.

And finally, with regard to the map that you created, please reflect on the following quote from Heather Krause, founder of [We All Count](https://weallcount.com): "maps only show people who aren't invisible to the makers" as well as Chapter 3 from @datafeminism2020 and add a few paragraphs related to this. If you have not now got at least two pages for the map, then you have likely written too little.


### Paper {.unnumbered}

::: {.content-visible when-format="pdf"}
At about this point the *Mawson* Paper in the ["Papers" Online Appendix](https://tellingstorieswithdata.com/23-assessment.html) would be appropriate.
:::

::: {.content-visible unless-format="pdf"}
At about this point the *Mawson* Paper from [Appendix -@sec-papers] would be appropriate.
:::


